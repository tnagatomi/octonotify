# frozen_string_literal: true

require "cgi"
require "mail"

module Octonotify
  class Mailer
    class DeliveryError < Octonotify::Error
      attr_reader :failed_recipients

      def initialize(failed_recipients)
        @failed_recipients = failed_recipients
        super("Failed to deliver to #{failed_recipients.size} recipient(s)")
      end
    end

    def initialize(config:, delivery_method: nil)
      @config = config
      @delivery_method = delivery_method || build_smtp_delivery
    end

    def send_digest(events)
      return if events.empty?

      text_body = build_text_body(events)
      html_body = build_html_body(events)
      subject = build_subject(events)

      failed = {}
      @config.to.uniq.each do |recipient|
        send_email(to: recipient, subject: subject, text_body: text_body, html_body: html_body)
      rescue StandardError => e
        failed[recipient] = e
      end

      raise DeliveryError, failed unless failed.empty?
    end

    private

    def build_smtp_delivery
      host = ENV.fetch("OCTONOTIFY_SMTP_HOST", nil)
      raise Octonotify::ConfigError, "OCTONOTIFY_SMTP_HOST environment variable is required" if host.nil? || host.empty?

      username = ENV.fetch("OCTONOTIFY_SMTP_USERNAME", nil)
      password = ENV.fetch("OCTONOTIFY_SMTP_PASSWORD", nil)

      smtp_settings = {
        address: host,
        port: parse_smtp_port(ENV.fetch("OCTONOTIFY_SMTP_PORT", nil)),
        enable_starttls_auto: true
      }

      if username && !username.empty?
        if password.nil? || password.empty?
          raise Octonotify::ConfigError, "OCTONOTIFY_SMTP_PASSWORD is required when OCTONOTIFY_SMTP_USERNAME is set"
        end

        smtp_settings[:user_name] = username
        smtp_settings[:password] = password
        smtp_settings[:authentication] = :plain
      end

      [:smtp, smtp_settings]
    end

    def parse_smtp_port(value)
      str = value.to_s.strip
      return 587 if str.empty?

      port = Integer(str, 10)
      return port if port.between?(1, 65_535)

      raise Octonotify::ConfigError, "OCTONOTIFY_SMTP_PORT must be a valid TCP port (1-65535)"
    rescue ArgumentError
      raise Octonotify::ConfigError, "OCTONOTIFY_SMTP_PORT must be a valid TCP port (1-65535)"
    end

    def send_email(to:, subject:, text_body:, html_body:)
      from_addr = @config.from
      delivery = @delivery_method

      mail = Mail.new do
        from    from_addr
        to      to
        subject subject

        text_part do
          content_type "text/plain; charset=UTF-8"
          body text_body
        end

        html_part do
          content_type "text/html; charset=UTF-8"
          body html_body
        end
      end

      if delivery.is_a?(Array)
        mail.delivery_method(*delivery)
      else
        mail.delivery_method(delivery)
      end
      mail.deliver
    end

    def build_subject(events)
      repo_count = events.map(&:repo).uniq.size
      event_count = events.size

      if repo_count == 1
        "[Octonotify] #{event_count} new event#{"s" if event_count > 1} in #{events.first.repo}"
      else
        "[Octonotify] #{event_count} new event#{"s" if event_count > 1} in #{repo_count} repositories"
      end
    end

    def build_text_body(events)
      grouped = events.group_by(&:repo)
      timezone = @config.timezone_info

      lines = []
      lines << "GitHub Activity Digest"
      lines << ""

      grouped.keys.sort.each do |repo|
        repo_events = grouped[repo].sort_by(&:time).reverse
        lines << repo
        lines << "https://github.com/#{repo}"
        lines << ""

        events_by_type = repo_events.group_by(&:type)
        event_type_order.each do |type|
          next unless events_by_type[type]

          lines << "  #{event_type_label(type)}"
          events_by_type[type].each_with_index do |event, idx|
            lines << format_text_event(event, timezone)
            lines << "" if idx < events_by_type[type].size - 1
          end
          lines << ""
        end
      end

      lines << "Generated by Octonotify"

      lines.join("\n")
    end

    def build_html_body(events)
      grouped = events.group_by(&:repo)
      timezone = @config.timezone_info

      html = []
      html << "<!DOCTYPE html>"
      html << "<html><head><meta charset=\"UTF-8\"></head><body>"
      html << "<h1 style=\"font-size: 18px;\">GitHub Activity Digest</h1>"

      grouped.keys.sort.each do |repo|
        repo_events = grouped[repo].sort_by(&:time).reverse
        repo_url = "https://github.com/#{repo}"
        html << "<div style=\"margin-bottom: 20px;\">"
        html << "<p style=\"font-size: 16px; font-weight: bold; margin-bottom: 4px;\">#{html_escape(repo)}</p>"
        html << "<p style=\"margin-top: 0;\">#{safe_link_html(repo_url)}</p>"

        events_by_type = repo_events.group_by(&:type)
        event_type_order.each do |type|
          next unless events_by_type[type]

          html << "<h3 style=\"font-size: 14px; margin: 10px 0 5px 10px;\">#{event_type_label(type)}</h3>"
          events_by_type[type].each_with_index do |event, idx|
            html << format_html_event(event, timezone)
            html << "<div style=\"height: 8px;\"></div>" if idx < events_by_type[type].size - 1
          end
        end
        html << "</div>"
      end

      html << "<p style=\"color: #666;\">Generated by Octonotify</p>"
      html << "</body></html>"

      html.join("\n")
    end

    def format_text_event(event, timezone)
      local_time = timezone.to_local(event.time)
      time_str = local_time.strftime("%Y-%m-%d %H:%M %Z")

      lines = []
      lines << "    #{event.title}"
      lines << "    #{event.url}"
      lines << "    Time: #{time_str}"

      case event.type
      when "release"
        lines << "    Tag: #{event.extra[:tag_name]}" if event.extra[:tag_name]
      when "pull_request_merged"
        lines << "    Author: #{event.author}" if event.author
        lines << "    Merged by: #{event.extra[:merged_by]}" if event.extra[:merged_by]
      when "pull_request_created", "issue_created"
        lines << "    Author: #{event.author}" if event.author
      end

      lines.join("\n")
    end

    def format_html_event(event, timezone)
      local_time = timezone.to_local(event.time)
      time_str = local_time.strftime("%Y-%m-%d %H:%M %Z")
      meta_style = "margin: 2px 0; color: #666;"
      title = html_escape(event.title)

      html = []
      html << "<div style=\"margin-left: 20px; margin-bottom: 10px;\">"
      html << "<p style=\"margin: 0;\">#{title}</p>"
      html << "<p style=\"margin: 2px 0;\">#{safe_link_html(event.url)}</p>"
      html << "<p style=\"#{meta_style}\">Time: #{time_str}</p>"

      case event.type
      when "release"
        html << "<p style=\"#{meta_style}\">Tag: #{html_escape(event.extra[:tag_name])}</p>" if event.extra[:tag_name]
      when "pull_request_merged"
        html << "<p style=\"#{meta_style}\">Author: #{html_escape(event.author)}</p>" if event.author
        if event.extra[:merged_by]
          html << "<p style=\"#{meta_style}\">Merged by: #{html_escape(event.extra[:merged_by])}</p>"
        end
      when "pull_request_created", "issue_created"
        html << "<p style=\"#{meta_style}\">Author: #{html_escape(event.author)}</p>" if event.author
      end

      html << "</div>"
      html.join("\n")
    end

    def event_type_order
      %w[release pull_request_merged pull_request_created issue_created]
    end

    def event_type_label(type)
      case type
      when "release" then "Release"
      when "pull_request_merged" then "PR Merged"
      when "pull_request_created" then "PR Created"
      when "issue_created" then "Issue Created"
      else type
      end
    end

    def html_escape(text)
      CGI.escapeHTML(text.to_s)
    end

    def safe_link_html(url)
      escaped_url = html_escape(url)
      if url.to_s.match?(%r{\Ahttps?://})
        "<a href=\"#{escaped_url}\">#{escaped_url}</a>"
      else
        escaped_url
      end
    end
  end
end
